import abc
from typing import Protocol, runtime_checkable, Union, Sequence, Any, Iterable, TypeVar, Type, overload

T = TypeVar('T', bound='Array')

@runtime_checkable
class Mask(Protocol):
    """Boolean array of length N."""
    def __and__(self,  other: 'Mask') -> 'Mask': ...
    def __or__(self,   other: 'Mask') -> 'Mask': ...
    def __xor__(self,  other: 'Mask') -> 'Mask': ...
    def __invert__(self)           -> 'Mask': ...
    def any(self)                  -> bool: ...
    def all(self)                  -> bool: ...
    def __getitem__(self, idx: Any) -> 'Mask': ...  # e.g. submask
    def copy(self) -> 'Mask': ...
    @property
    def index(self) -> Any: ...

class MaskABC(abc.ABC):
    @abc.abstractmethod
    def __iter__(self):
        pass
    def __and__(self, other: 'Mask') -> 'Mask':
        return type(self)([a and b for a, b in zip(self, other)])
    def __or__(self, other: 'Mask') -> 'Mask':
        return type(self)([a or b for a, b in zip(self, other)])
    def __xor__(self, other: 'Mask') -> 'Mask':
        return type(self)([bool(a) ^ bool(b) for a, b in zip(self, other)])
    def __invert__(self) -> 'Mask':
        return type(self)([not a for a in self])
    def any(self) -> bool:
        return any(self)
    def all(self) -> bool:
        return all(self)
    def __getitem__(self, idx: Any) -> 'Mask':
        # Default: assume self is indexable and returns same type
        return type(self)(list(self)[idx])

@runtime_checkable
class Array(Protocol):
    """Supports comparisons, arithmetic, and casting to bool masks."""
    # comparisons â†’ Mask
    def __eq__(self,  other: 'Array') -> Mask: ...
    def __ne__(self,  other: 'Array') -> Mask: ...
    def __lt__(self,  other: 'Array') -> Mask: ...
    def __le__(self,  other: 'Array') -> Mask: ...
    def __gt__(self,  other: 'Array') -> Mask: ...
    def __ge__(self,  other: 'Array') -> Mask: ...

    # arithmetic â†’ ArrayLike
    def __add__(self,  other: 'Array') -> 'Array': ...
    def __sub__(self,  other: 'Array') -> 'Array': ...
    def __mul__(self,  other: 'Array') -> 'Array': ...
    def __truediv__(self, other: 'Array') -> 'Array': ...
    def __floordiv__(self, other: 'Array') -> 'Array': ...
    def __mod__(self,  other: 'Array') -> 'Array': ...
    def __pow__(self,  other: 'Array') -> 'Array': ...
    def __neg__(self)              -> 'Array': ...

    def __iter__(self) -> Iterable[Any]: ...

    # to support regex / Comparison(None)
    def astype(self, dtype: Any)  -> 'Array': ...  
    def isin(self, values: Iterable) -> Mask: ...
    def str_contains(self, pattern: str, regex: bool = True) -> Mask: ...
    # short-circuit checks
    def any(self) -> bool: ...
    def all(self) -> bool: ...
    def __getitem__(self, idx: Any) -> Any: ...  # e.g. for sub-arrays
    def copy(self) -> 'Array': ...
    @property
    def index(self) -> Any: ...
    @classmethod
    def filled(cls: Type[T], value: Any, index: Any) -> T: ...
    def set_by_index(self: T, index: Any, value: Any) -> None: ...

class ArrayABC(abc.ABC):
    @abc.abstractmethod
    def __iter__(self):
        pass
    def __eq__(self, other: 'Array') -> Mask:
        return type(self)([a == b for a, b in zip(self, other)])
    def __ne__(self, other: 'Array') -> Mask:
        return type(self)([a != b for a, b in zip(self, other)])
    def __lt__(self, other: 'Array') -> Mask:
        return type(self)([a < b for a, b in zip(self, other)])
    def __le__(self, other: 'Array') -> Mask:
        return type(self)([a <= b for a, b in zip(self, other)])
    def __gt__(self, other: 'Array') -> Mask:
        return type(self)([a > b for a, b in zip(self, other)])
    def __ge__(self, other: 'Array') -> Mask:
        return type(self)([a >= b for a, b in zip(self, other)])
    # Arithmetic methods can be similarly implemented if needed.
    @abc.abstractmethod
    def any(self) -> bool:
        pass
    @abc.abstractmethod
    def all(self) -> bool:
        pass
    @abc.abstractmethod
    def __getitem__(self, idx: Any) -> Any:
        pass
    @abc.abstractmethod
    def astype(self, dtype: Any) -> Any:
        pass

# The container of atoms/residues/etc.:
@runtime_checkable
class Structure(Protocol):
    """Any per-atom container, indexed either by name or by mask/indices."""
    def len(self) -> int: ...
    def get_property(self, key: Union[str, Mask, Sequence[int]]) -> Array: ...
    def select(self, mask: Mask) -> 'Structure': ...
    @property
    def index(self) -> Any: ...
    @property
    def columns(self) -> Iterable[str]: ...
    def get_coordinates(self, columns: Sequence[str]) -> Any: ...
    def array_filled(self, value: Any) -> Array: ...
    def array_values(self, values: Any) -> Array: ...
    def minimum_pairwise_distances(self, target: 'Structure') -> Array: ...
